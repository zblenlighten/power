# Knowledge Memo

## Blogs

- [Engineering Blogs](https://github.com/kilimchoi/engineering-blogs)
- [Top 100 on GitHub](https://twosigmaventures.com/open-source-index/)

## Contents

- [Infrastructure](#infrastructure)
- [Data storage](#data-storage)
- [Dataflow](#dataflow)
- [Backend](#backend)
- [Frontend](#frontend)
- [System design](#system-design)
- [Practice](#practice)

## Development

### Infrastructure

- Architecture: organize business, technology and staff to drive business growth
  - Application Landscape
    - Monolith
      - Cons: agility, scalability, fault tolerance, single framework
    - Multitier architecture (N-tier): an MVC design is often implemented using an 3-tier architecture
    - Service-oriented architecture (SOA)
    - Microservices
      - Pros: single capabilities, independent as product, decoupling, continuous delivery, componentization, autonomy, scalability
      - When not to use: small, intermingled functionality or data, performance sensitive, quick and dirty, no planned updates
      - Kubernetes
        - Service Mesh: Istio
      - Componentization via services
        - Service discovery (SDP, Eureka service registry)
        - API Gateway ([WSO2](https://apim.docs.wso2.com/en/latest/get-started/key-concepts/), Kong, Tyk, Zuul)
          - Gateway = Route (basic building block) + Filter (optional function)
        - Load balancing (Nginx)
      - Interservice communication
        - Synchronous - One-to-one: Request and response
        - Asynchronous - One-to-one: Notification, Request and asynchronous response
        - Asynchronous - One-to-many: Publish and subscribe, Publish and asynchronous responses
      - Challenges
        - Design and runtime complexity
        - Network are slow compared to monolith
      - [Microservices Patterns](https://microservices.io/patterns/)
    - Serverless (run in stateless compute containers that are event triggered)
      - Principles: Invisible infrastructure, Automatic scaling, No paying for unused CPU cycles
      - Function as a Service
        - AWS Lambda
        - Google Cloud Functions
      - Backend as a Service
        - Firebase
    - Peer-to-peer
      - Peer-to-peer file sharing: BitTorrent
  - Distributed system (storage + computation + messaging)
    - Fault-tolerant Consensus: for solving consensus in a network
      - Properties: uniform agreement, integrity, validity, termination
      - Consensus algorithms: Paxos, Raft, Zab (ZooKeeper)
      - [ZooKeeper](https://zookeeper.apache.org/doc/current/zookeeperInternals.html) (vs: Chubby)
        - Features: linearizable atomic operations, total ordering operations, failure detection, change notifications
        - Central coordinator: manage state and hold configuration (ZooKeeper ensemble)
        - Recover from partial failures: master crashes, worker crashes, network trouble
        - Service discovery: leader election
        - Membership / coordination service
    - [Thrashing in Distributed Shared Memory](https://www.geeksforgeeks.org/distributed-system-thrashing-in-distributed-shared-memory/)
  - Communication patterns
    - Synchronous
      - REST
      - RPC
    - Asynchronous
      - publish–subscribe: WebSocket, MQTT
      - message queue / message broker: RabbitMQ, Kafka
      - stream: server-sent events, WebRTC
    - Event-driven
      - webhooks (an HTTP callback, vs: API polling)
      - event-based architectures: Event sourcing, Event-driven microservices
  - Others
    - Single vs Multi-tenant
    - User Interface (UI)
      - MVC: model view controller
      - MVP: model view presenter
      - MVVM: model view viewmodel
      - MVVM-C: model view viewmodel coordinator
      - VIPER: view interactor presenter entity router
    - Tools
      - Backstage

- DevOps
  - Version control
    - Git (tag - branch)
    - dvc: data version control (vs: Git LFS, lakeFS)
  - Infrastructure as code (consider hardware: networks, servers, storage, etc.)
    - Terraform: Write -> Plan -> Apply
      - [terraformer](https://github.com/GoogleCloudPlatform/terraformer)
    - Ansible ([YAML](http://www.ruanyifeng.com/blog/2016/07/yaml.html))
    - Provision: Dockerfile / Puppet / Chef
    - [checkov](https://raw.githubusercontent.com/bridgecrewio/checkov/master/docs/5.Policy%20Index/all.md)
  - Configuration (deploy and configure software: operating systems, applications, etc.)
    - CI/CD: automating the stages of app development (Jenkins)
      - Continuous integration: build -> test -> merge
      - Continuous delivery: automatically release to repository
      - Continuous deployment: automatically deploy to production
    - Automation vs Orchestration
      - Automation refers to a single task
      - Orchestration refers to the management of many automated tasks, often a complicated ordering with dependencies
  - Container
    - Docker
      - Manage kernel features
        - cgroups: processes
        - namespaces: networks
        - copy-on-write: unionfs
      - Docker components
        - Dockerfile -> Docker Client -> Docker Host (images, containers, volumes) -> Docker Registry
        - Dockerfile: multi-stage builds
      - Nvidia docker
    - Kubernetes (vs: Docker Compose, Apache Mesos)
      - Pod - Node - Cluster
      - ReplicaSet
      - etcd
      - GitOps: ArgoCD
      - Tools: [lens](https://k8slens.dev/), [starboard](https://aquasecurity.github.io/starboard/), [karpenter](https://karpenter.sh/), [infra](https://infrahq.com/), [argo](https://argoproj.github.io/)
  - Observability
    - Metrics: metrics are measurements at a point in time in a system, they can be visualized in various types of graphs such as gauges, counters, and timers, metrics are great for monitoring, profiling, and alerting (do I have a problem)
      - System metrics (CPU, memory, disk)
      - Infrastructure metrics (AWS CloudWatch)
      - Web tracking scripts (Google Analytics)
      - Application agents (performance, error tracking)
        - Application performance management (APM)
        - Real user monitoring (RUM)
      - [Monitoring Distributed Systems](https://sre.google/sre-book/monitoring-distributed-systems/#xref_monitoring_golden-signals)
    - Logging: log messages are sets of data generated by the system when an event has happened, logs provide the extra level of detail necessary for troubleshooting, debugging, support, and auditing (what is causing the problem)
      - System logs (syslog, journald)
      - Application logs (log4j, log4net)
      - Server logs (Apache, MySQL)
      - Platform logs (AWS CloudTrail)
      - Logs can yield metrics
        - Collection -> Transport -> Storage (centralized) -> Analysis
    - [Tools](https://github.com/adriannovegil/awesome-observability)
      - [Metrics, monitors, alerts decision record](https://github.com/joelparkerhenderson/architecture-decision-record/tree/main/locales/en/examples/metrics-monitors-alerts)
      - ELK (Elastic)
        - Elasticsearch
        - Logstash (vs: Fluentd, Embulk): Data collection pipeline
          - Filter plugin: Grok (log parser)
          - Input plugin: Twitter
        - Kibana: Viewer with filter capabilities
          - Kibana Query Language (KQL)
        - [Beats](https://www.elastic.co/guide/en/beats/libbeat/current/beats-reference.html): Data shipping
      - New Relic
        - [OpenTelemetry](https://github.com/newrelic/newrelic-opentelemetry-examples)
      - Splunk
        - [data pipeline](https://docs.splunk.com/Documentation/Splunk/latest/Deploy/Datapipeline)
        - Components: Forwarder, Indexer, Search head
      - Datadog
    - [Security Analytics](https://www.paloaltonetworks.com/cyberpedia/security-analytics)
  - Security
    - Considerations
      - Organization: People, Processes, and Policies
      - Data & AI
        - PII Classification / Detection
          - [What is the difference between personally identifiable information (PII) and personal data?](https://techgdpr.com/blog/difference-between-pii-and-personal-data/)
        - Anonymization Functions (vs: Pseudonymization)
        - Encryption Options (e.g. Customer Managed Key, CMK)
      - Platform & Infrastructure
        - Secure Authentication (e.g. Multi Factor Authentication, MFA)
        - Secure Data Access Configurations (e.g. Storage Firewalls, [Network Connectivity Configuration](https://docs.databricks.com/api/azure/account/networkconnectivity/createnetworkconnectivityconfiguration))
        - Data Exfiltration Protection (e.g. Secure Egress Gateway)
        - Secure Platform Configurations (e.g. Disable Personal Access Tokens)
        - Automation, Logging, and Monitoring
        - DevSecOps
          - Toolchain: Pre-commit -> Commit (continuous integration) -> Acceptance (continuous delivery) -> Production (continuous deployment) -> Operations
          - Legacy tools
            - Static application security testing (SAST): find security bugs
            - Dynamic application security testing (DAST): ZAP, WebInspect
            - Interactive application security testing (IAST)
            - Vulnerability scanning: OpenVAS
            - Others: sqlmap, Recon-ng, OWASP Glue
          - [Top 10 CI/CD Security Risks](https://github.com/cider-security-research/top-10-cicd-security-risks)
        - Vault
          - Data in transit: TLS encrypts data between server and client (asymmetric)
          - Internal data: AES256 (symmetric, faster)
          - Key sharding: the master key is split into several unseal keys using Shamir's Secret Sharing (two-man rule)
          - Authentication: data that must be kept confidential is a secret, access to secret is performed by token
            - wrap-ttl: generate a wrapping token
          - Policy (Authorization): policy is associated to tokens and grants capabilities to a secrets engine path
          - AppRole: Jenkins
    - Cybersecurity
      - Penetration test & Vulnerability scan
      - Thread detection & Incident response
    - Compliance
      - [Security Compliance: A Complete Introduction](https://www.splunk.com/en_us/blog/learn/security-compliance.html)
      - [What is NIST CSF and why is it important?](https://www.vanta.com/resources/what-is-nist-csf-and-why-is-it-important)
      - [Do you need penetration testing for compliance?](https://www.vanta.com/resources/do-you-need-penetration-testing-for-compliance)
    - [Web Application Security Checklist](https://www.appsecmonkey.com/blog/web-application-security-checklist)
  - Others
    - OpenStack
    - Vagrant: synced folder, networking, provider (hypervisor), provisioner
    - Packer: co-ordinates the lifecycle of image (for containers and virtual machines) creation, provision with simple scripting or configuration management tool such as Ansible

### Data storage

- Basic topics
  - Storage Engines
    - Log-structured storage engine: SSTable -> LSM Tree
      - Database: LevelDB, Cassandra, HBase, Lucene
    - Page oriented storage engine: B tree
      - All major relational databases and some nonrelational ones
  - Index
    - Primary key & Secondary index
      - Secondary index: Gloabl secondary index (asynchronous updating), Local secondary index
    - clustered index - covered index - only reference index (write amplification)
    - Multi-column index: Geohash, R tree
    - Fuzzy index (full-text search)
  - Query Tuning
    - Index types
      - B tree
      - Bitmap
      - Hash
      - Specialized index
    - Joins (PostgreSQL: vacuum & analyze)
      - Nestloop
      - Hashjoin
      - Mergejoin
    - Partitioning / [Sharding](https://www.digitalocean.com/community/tutorials/understanding-database-sharding) (horizontal partitioning)
      - Range
      - List
      - Hash
    - **Materialized view** (vs: view) - OLAP Cube
  - Filesystem ACL (file vs blob: binary large object)
    - blob storage: relational db, file system, object storage (Ceph), cloud storage
    - [Signed URLs](https://cloud.google.com/storage/docs/access-control/signed-urls)
  - Replication
    - Approaches
      - Single leader
      - Multi leader
      - Leaderless
    - Write conflict resolution
      - [Conflict-free replicated data type](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type) (CRDT)
      - Operational transformation (collaborative editing, [demo](http://operational-transformation.github.io)): Google Docs
  - Partition
    - Approaches: Key range, Hash of key
    - **Secondary index** (full-text index is a particular kind of secondary index)
      - Document partitioned index / Local index: scatter/gather (tail latency amplification)
      - Term partitioned index / Global index (more efficient reads, however more complicated writes)
  - Transaction
    - [Transaction log](https://en.wikipedia.org/wiki/Transaction_log)
      - [Log-based Incremental Replication](https://www.stitchdata.com/docs/replication/replication-methods/log-based-incremental)
      - Log compaction
    - Safety guarantees (ACID)
      - Atomicity
      - Consistency: maintain database invariants (a transaction can only bring the database from one valid state to another)
      - Isolation: avoid race conditions due to concurrently executing transactions
        - Serializability
          - Pessimistic concurrency control: Java synchronized, MySQL exclusive lock (InnoDB locking)
            - Actual serial execution
            - Two-phase locking (2PL): provide serializable isolation
          - Optimistic concurrency control: version, timestamp, compare and swap (CAS)
            - Serializable snapshot isolation (SSI)
        - Snapshot isolation (Repeatable reads)
          - Implementation: multi-version concurrency control (MVCC)
          - Problems: Lost updates, Write skew
        - Read committed (vs: Read uncommitted)
      - Durability
  - Consensus (recency guarantee)
    - Linearizability / Sequential consistency: coordinate the state of replicas in the face of delays and faults
      - CAP: Consistency, Availability, Partition tolerance
        - CP (Linearizability) vs AP (BASE: Basically Available Soft state Eventual consistency)
    - Total order broadcast (e.g. ZooKeeper Atomic Broadcast, ZAB)
    - Two-phase Commit (2PC): provide atomic commit in a distributed database
  - Connection pooling - [Bulkhead](https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead)

- RDBMS (Relational Database Management System)
  - Pros: SQL, normalized data (minimize chances of introducing problem), widely used across domains, widely supported
  - Cons: fixed schema (each record), costly to join tables, limited data structures, difficult to horizontal scale (vertically scalable)
    - Workarounds: denormalization, sharding, replication (master and read replicas)
  - SQL query -> Server connector -> Parser (parse tree) -> Optimization -> Execution (InnoDB vs MyIsam, [区别](https://www.zhihu.com/question/20596402))
  - Keys: Super key, Candidate key, Primary key, Foreign key
  - PrepareStatement
    - Get pre compiled and access plan cached in database
    - Prevent SQL Injection attacks
  - Database design
    - Logical structuring: ER diagram (entity–relationship model)
    - Physical design
    - [Logical data model vs Physical data model](https://aws.amazon.com/compare/the-difference-between-logical-and-physical-data-model/)
    - Database normalization
      - Organizing the columns (attributes) and tables (relations) to ensure that their dependencies are properly enforced by database integrity constraints
      - Normal forms
      - [Denormalization](https://www.geeksforgeeks.org/denormalization-in-databases/)
    - [ORM](http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html): Object-relational mapping
  - [Collation and Unicode](https://learn.microsoft.com/en-us/sql/relational-databases/collations/collation-and-unicode-support?view=sql-server-ver16)

- NoSQL
  - Pros: flexible schemas, distributed (horizontally scalable, designed to be scaled across multiple servers), replication
  - Key-value (fast & light: caching stores, managing user sessions, ad servicing, recommendations)
    - Redis ([点赞功能](https://juejin.im/post/5bdc257e6fb9a049ba410098), vs: [Ignite](https://github.com/apache/ignite), [Hazelcast](https://github.com/hazelcast/hazelcast))
      - Caching: cache objects or pages, which helps to protect the database from overloading
      - Session: share user session data between stateless servers
      - Distributed lock: provide mutually exclusive access to shared resources
      - Counter and Rate limiter: count the number of times a resource is accessed and also enforce rate limits on our endpoints
      - Leaderboard: Sorted Set is a nice way to implement leaderboard
    - LevelDB (Riak: CRDTs)
  - Wide-column (row-oriented, reduce disk resources & fast querying and processing: big data store)
    - Cassandra
      - Table - Keyspace
      - Primary key - **Partition** key - Cluster key
      - Index: primary - secondary - cost
      - Replication: leaderless (no master node -> no single point of failure)
      - Gossip protocol
      - CQL, CQLSH
      - Tips
        - data is denormalized and ordered: no normalization
        - eventual consistency so read operation can return inconsistent data: read from multiple replicas
        - data duplication and missing columns are common
        - [Why Cassandra doesn’t need vector clocks](https://www.datastax.com/blog/why-cassandra-doesnt-need-vector-clocks)
    - HBase
    - Amazon DynamoDB
  - Document (schema flexibility: managing user profiles, XML or JSON documents)
    - MongoDB
      - Document - Collection - Database
      - Replication: single leader
      - Support many indices (only one can be used for sharding): text search, geospatial
    - CouchDB
    - [Elasticsearch](http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html)
      - Document with properties - Index
        - Scheme-free JSON (distributed document storage)
      - Percolator: search on streams
      - Node discovery and cluster management: [built-in subsystem](https://www.elastic.co/blog/a-new-era-for-cluster-coordination-in-elasticsearch)
  - Graph database
    - Neo4j (property graph model, vs: triple-store model)
      - Graph: hierarchical or nonhierarchical, number of nodes and edged, the longest distance between nodes
      - Nodes (entity) - Properties (columns in a relational database table)
      - Edges (relationship): directed or undirected, symmetric or asymmetric
      - Cypher query language
      - Tips
        - Traverse paths instead of joins
        - Identify important nodes
        - Consider the weigh of edges
        - Beware of cycles: it's possible to visit same node repeatedly
  - Ledger database
    - Hyperledger
  - Time series database / Sequence database
    - InfluxDB
    - q/kdb+ ([PyKX](https://github.com/kxsystems/pykx))
    - Chroma
  - Others
    - [VoltDB](https://en.wikipedia.org/wiki/VoltDB)
    - [Spanner](https://cloud.google.com/spanner)

- Search Engine
  - Lucene + Inverted Index
    - Characteristics: text centric, read dominant, document oriented, flexible schema, large volumes of data
    - Solr
      - Solr core - Jetty web server - Java JVM
      - Documents, fields and schema design
        - Solr's data modeling consists of denormalized documents, meaning all the data that belongs to an entity is in the same document
      - Indexing
        - Updating parts of documents: atomic updates, in-place updates, optimistic concurrency (version)
        - Commit: data sent to Solr is not searchable until it has been committed to the index
          - auto commit: tradeoff between performance and accuracy
        - Nested child documents
        - Reindexing: schema changes, Solrconfig changes, upgrade
      - Text Analysis
        - Analyzer - Tokenizer - Filter
      - Searching
        - Relevance score (e.g. TF-IDF)
        - Near real time searching: soft commit (vs: hard commit)
        - Request handlers (SearchHandler) -> Search components (QueryComponent) -> Query parser (Lucene)
        - Query syntax and parsing
          - Query parameters
          - Standard query parser
            - Term modifiers: wildcard search, fuzzy search, range search, boosting
        - Faceted search: field faceting, query faceting, range faceting
      - Node discovery and cluster management: ZooKeeper
    - Elasticsearch
      - [Similarity](https://www.elastic.co/guide/en/elasticsearch/reference/current/similarity.html): BM25
  - Image search
    - Thumbnail

- Caching
  - In-memory database (Cache + Processing / Querying)
    - Types
      - Application server cache: placing a cache on request layer node enables the local storage of response data
      - Distribute cache: each of its nodes own part of cached data, the cache is divided up using consistent hashing
      - Global cache: all nodes use the same single cache space
    - Client-side cache: Varnish
    - Cache coherence / invalidation
      - Writing policies
        - Write-through cache: data is written to cache & DB at the same time, this minimizes the risk of data loss, but higher latency for write
        - Write-around cache: data is written directly to DB, this reduces flooded write operations, but creates a cache miss
        - Write-back cache: data is written to cache alone, this results in low latency & high throughput, but comes with the risk of data loss in case of crash
      - Distributed lock manager (DLM)
    - Considerations: when data is read frequently but modified infrequently
      - Expiration policy
      - Consistency
      - Mitigating failures
      - [Eviction policy](https://en.wikipedia.org/wiki/Cache_replacement_policies)
  - Content Delivery Network (CDN): cacheable content such as images and videos (static content vs dynamic content)
    - Benefits (first request ask the CDN for data, if not, CDN will query the backend servers)
      - Improving website load times
      - Reducing bandwidth costs
      - Increasing content availability and redundancy
      - Improving website security
      - Time to live (TTL) features for certain uses cases
    - Fastly, Cloudflare, Amazon CloudFront
      - [How is AWS Global Accelerator different from Amazon CloudFront](https://aws.amazon.com/global-accelerator/faqs/)
    - [CDN工作原理及其在淘宝图片业务中的应用](https://blog.csdn.net/taobaojishu/article/details/110458820)

- Data Warehouse
  - Analytic systems (OLAP: online analytical processing)
    - Cloud data warehouse: Redshift, BigQuery, Ads Data Hub, Azure Synapse Analytics, Snowflake ([Unistore](https://www.snowflake.com/en/data-cloud/workloads/unistore/) - [Snowpark](https://www.snowflake.com/en/data-cloud/snowpark/)), [Hologres](https://www.alibabacloud.com/help/en/hologres/product-overview/what-is-hologres)
    - On-premises data warehouse: Netezza, [Druid](https://druid.apache.org/use-cases/), Hive, Teradata, Greenplum
    - Column-oriented (Bitmap encoding vs Run-length encoding)
    - Main read pattern: aggregate over large number of records
    - Main write pattern: bulk import (ETL) or event stream
    - Vectorized Processing in CPU cache
    - Data modeling
      - Dimensional model (fact + dimension)
        - Star Schema: denormalized, better query performance
        - Snowflake Schema: normalized, better data integrity
        - Slowly changing dimension (SCD)
      - Normalization (e.g. third normal form)
    - High availability and low latency (business Intelligence: optimization for analytic access patterns)
    - Late Arriving data (late arriving dimensions / early arriving facts)
  - Transaction processing systems (OLTP: online transaction processing)
    - Database: MySQL, PostgreSQL, etc.
    - Row-oriented
    - Main read pattern: small number of records per query, fetched by key
    - Main write pattern: random access, low latency writes from user input
  - References
    - [Difference between Kimball and Inmon](https://www.geeksforgeeks.org/difference-between-kimball-and-inmon/)
    - [Data Vault](https://www.databricks.com/glossary/data-vault)
    - [Star schema vs OBT](https://www.fivetran.com/blog/star-schema-vs-obt)

- Vector database
  - Model
    - Contrastive Language-Image Pre-training ([CLIP](https://huggingface.co/docs/transformers/model_doc/clip)): understand both types of image and text data and can generate vectors for each type which can then be compared
  - Approximate Nearest Neighbor (ANN)
    - Hierarchical Navigable Small Worlds (HNSW)
  - Weaviate: [Cross-references](https://weaviate.io/developers/weaviate/manage-data/cross-references), [Hybrid search](https://weaviate.io/developers/weaviate/search/hybrid) (alpha)
  - References
    - [vecdbs](https://www.vecdbs.com/)

- Others
  - How to Choose: Integration, Scaling, Support(security, budget), Simplicity
  - Types of analyze to structure data
    - Machine learning and statistics: tables and data frames
    - Real time analysis: queues and streams
    - Network analysis: graphs
  - References
    - [A map of storage options in Google Cloud](https://cloud.google.com/blog/topics/developers-practitioners/map-storage-options-google-cloud)
    - [Lambda or Kappa? The need for a new data processing architecture](https://www.qlik.com/blog/lambda-or-kappa-the-need-for-a-new-data-processing-architecture)
    - [Modern Data Stack Guide](https://notion.castordoc.com/modern-data-stack-guide)
    - [Big data architectures](https://docs.microsoft.com/en-us/azure/architecture/data-guide/big-data/)
    - [Data Mesh](https://atlan.com/what-is-data-mesh/) [Architecture](https://www.datamesh-architecture.com/): unify data access across the company while retaining ownership of the data in distributed domains
    - [List of data engineering tools](https://github.com/igorbarinov/awesome-data-engineering)
    - [Open source data-diff](https://www.datafold.com/blog/open-source-data-diff)
    - Clustered index: [Clustered table in BigQuery](https://cloud.google.com/bigquery/docs/clustered-tables)

### Dataflow

- Basic topics
  - Schema evolution
    - Rolling upgrade
    - Backward compatibility: newer code read data that was written by older code (vs: Forward compatibility)
      - Full compatibility
      - Backward compatibility in machine learning
    - Encoding / Serialization: from data structures in memory to self-contained sequence of bytes, **write** to file or send over network (e.g. [Java serialization](https://www.geeksforgeeks.org/serialization-in-java/) & [Kryo](https://github.com/EsotericSoftware/kryo), [Python pickle](https://www.liaoxuefeng.com/wiki/1016959663602400/1017624706151424))
    - Decoding / Deserialization / Parsing: bytes to string, **read** or receive
    - Textual formats: JSON/JSONL, XML, CSV
    - Binary encoding formats: Thrift, Protocol Buffers, Avro
  - Modes of dataflow
    - ~~Database~~
    - Service calls (RPC vs REST API)
    - Asynchronous message passing (via message broker or [actor](https://github.com/akka/akka))
  - [Comparison of different file formats in Big Data](https://www.adaltas.com/en/2020/07/23/benchmark-study-of-different-file-format/)

- Hadoop
  - **HDFS** (Hadoop Distributed File System: NameNode - DataNode, Storage)
  - **Yarn** (cluster resource management, vs: Mesos)
  - **MapReduce** (distributed computation: input, split, map, [shuffle](https://spark.apache.org/docs/latest/rdd-programming-guide.html#shuffle-operations), reduce, output)
    - Reduce-side joins
      - Sort-merge joins
    - Map-side joins
      - Broadcast hash joins (Spark SQL)
      - Partitioned hash joins
  - Spark (Livy)
    - Resilient Distributed Dataset (RDD) - DataSet
      - Fault tolerance: tracking the the intermediate states of the data
    - Components: Spark Core - Spark SQL - spark.ml - Spark Streaming - GraphFrames (Pregel API)
    - Spark streaming (work on microbatching)
      - Batch interval vs Slide interval vs Window interval
    - Tez (coordinated by YARN)
    - References
      - [Spark — debugging a slow Application](https://blog.devgenius.io/spark-debugging-a-slow-application-7c6e781dc20f)
      - [PySpark Style Guide](https://github.com/palantir/pyspark-style-guide)
  - Pig (AvroStorage, Skewed Joins)
  - Hive (vs: Impala)
    - Hive Metastore Server (HMS): metadata
    - HiveQL (easier OLAP query than Mapreduce in Java), scalable, interactive
    - High latency (not appropriate for OLTP), no transactions, no record (because under the hood there are no real database)
  - HBase ([Bigtable](https://en.wikipedia.org/wiki/Bigtable), vs: Accumulo)
    - ZooKeeper
    - Access ways: HBase shell, Java API, Spark, Hive, Pig, Rest API, Thrift, Avro
  - Data ingestion: Sqoop (relational database), Flume (source -> channel -> sink), Kafka
  - Query engine: Hue, Drill (Dremel), Phoenix (HBase), Presto and Trino
  - Security: Ranger

- Data Stack
  - Data Integration
    - Data pipeline patterns
      - ETL: common data processing tasks are handled after the data is loaded to the DWH
      - ELT (Extract, Load, Transform) - EL
      - CDC ([Change data capture](https://www.qlik.com/us/change-data-capture/cdc-change-data-capture))
    - Data validations: file validations & archival (data source -> staging / data lake & data transformation)
    - Business validations: calculations & aggregations (staging -> data warehouse - data mart)
    - Airflow (web server + scheduler + metadata database + executor + worker, vs: Luigi)
      - Directed Acyclic Graph (DAG)
      - Operator: action, transfer, sensor
      - Executor: Sequential, Local, Celery, K8s (get the tasks to run from its internal queue and specify how to execute it)
        - Celery: tasks queues to distribute work across threads or machines
      - CI/CD pipeline with Airflow image containing DAGs: Github repo -> Jenkins -> K8s -> Pod
  - Data Transformation
    - dbt: data build tool
    - SDF ([repo](https://github.com/sdf-labs/sdf-cli))
  - Data Management
    - OpenMetadata
    - Data lineage
    - Data quality / testing
    - Schema migration (keep database schema in sync with application code): [Liquibase](https://docs.liquibase.com/home.html), [Flyway](https://documentation.red-gate.com/fd)
  - Data Migration
    - Main pillars: business outcomes, stakeholders, technology
    - Steps
      - Preparation and Discovery
      - Assessment and Plan
        - Make the process measurable
        - Start with MVP/PoC: Quick wins (priority 0 workloads)
        - Project plan: time, cost, people
        - Overcommunicate at milestones
      - Execution
        - Architecture and Feature Mapping Workshop
        - Data Migration: schema/data
        - Data Pipeline Migration: query transpile
        - Downstream Tools Integration
      - Optimization
    - Final checks: functional test, performance test, data integrity check
    - Others
      - [Bandwidth Calculator](https://www.calculator.net/bandwidth-calculator.html)
  - Batch: file (a sequence of bytes)
    - Problems: partitioning, fault tolerance
    - Graph processing: GraphChi, Pregel (PageRank)
  - Stream: event (a record of something that happened at some point in time)
    - Windows: Tumbling window, Hopping window, Sliding window, Session window
    - Stream joins: stream-stream, stream-table, table-table
    - Problems: fault tolerance and exactly once semantics
      - Microbatching and Checkpointing, Transaction, Idempotent writes
    - Streaming is unbounded data - Continuous is unbounded execution
    - Applications
      - Storm (work on individual events, truly real-time processing compared with Spark streaming)
        - Tuples: Topology (Spouts and Bolts)
        - Nimbus - ZooKeeper - Supervisor
      - Flink (faster than Storm, work on events, highly scalable, fault tolerant using [state snapshots](https://ci.apache.org/projects/flink/flink-docs-master/docs/learn-flink/fault_tolerance/))
        - Standalone cluster / YARN on Hadoop / Cloud / Local - Flink runtime - API
  - Database and Stream: keeping systems in sync
    - Capture the changelog (downside: asynchronous)
      - CDC
      - Event sourcing
    - Command query responsibility segregation ([CQRS](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)): deriving several views from the same event log
  - Open data storage format
    - Delta Lake (transaction log) -> Lakehouse
      - [Delta Lake Z Order](https://delta.io/blog/2023-06-03-delta-lake-z-order/)
      - [Delta UniForm](https://www.databricks.com/blog/delta-uniform-universal-format-lakehouse-interoperability): allow you to read Delta tables with Iceberg and Hudi clients
    - Hudi (Hadoop Upserts Deletes and Incrementals)
    - [Comparison of Delta Lake, Iceberg and Hudi](https://www.youtube.com/watch?v=Wx8G08jaedo)
  - References
    - [Comprehensive Data Catalog Comparison](https://www.onehouse.ai/blog/comprehensive-data-catalog-comparison)

- Message broker
  - Message: a client's request of a sequence of bytes with some metadata
  - Advanced Message Queuing Protocol (AMQP) / Java Message Service (JMS) style message broker
    - Situation: expensive message processing, parallelize processing on a message-by-message basis, and message ordering is not so important
    - [RabbitMQ](https://www.rabbitmq.com/tutorials/amqp-concepts.html) (ZeroMQ, ActiveMQ)
      - publisher -> exchange -> queue -> consumer
      - [Dead Lettering](https://www.rabbitmq.com/dlx.html)
  - Log based message broker
    - Situation: high message throughput, each message is fast to process, and message ordering is important
    - Kafka
      - Storage layer: cluster -> brokers -> topics -> partitions -> segments -> records with offsets
        - Topics: append-only, immutable logs of events
        - Record Schema: [Schema registry](https://docs.confluent.io/platform/current/schema-registry/avro.html)
        - Topic partitioning: what if a topic gets too big for one computer or one computer is not reliable
          - Partitions count (each partition for a single topic runs at a throughput of about 10 MB/s)
          - Replication factor (set to 3 as default)
            - Data Plane: Replication Protocol
          - It is recommended that each broker to have up to 4K partitions and each cluster to have up to 200K partitions
          - Log compaction
          - Advertised Host: advertised.host.name, advertised.listeners (private IP or public IP)
        - Bootstrap server (connection + metadata request)
      - Compute layer: Core APIs
        - Producer
          - Configuration
            - acks
              - 0: it's ok to lose data
              - 1: leader broker ack requested and replica is not guaranteed
              - all: leader and in-sync replicas ack requested (min.insync.replicas), add latency and safety
            - retries, delivery.timeout.ms, max.in.flight.request.per.connection (set to 1 to ensure ordering of retries)
            - enable.idempotence (set to true to prevent duplicates)
            - compression.type ([snappy](https://github.com/google/snappy)), linger.ms, batch.size
          - Keys: key to partition hashing (unless the number of partition changes, vs: round robin)
          - Example: RTSP (Real time streaming protocol) producer
        - Consumer
          - read data from a topic in order within each partitions (subscribe vs assign to a partition and seek to offsets)
          - Consumer Groups (same group read from mutually exclusive partitions)
            - lag = log end offset - current offset
            - reset offset
            - rebalancing (when a consumer joins or leaves a group)
          - Consumer offsets
            - Message delivery semantics: at most once, at least once, exactly once
          - Internal threads
            - Detecting consumer down: Heartbeat.interval.ms (Session.timeout.ms)
            - Detecting big data processing issue: max.poll.interval.ms
        - Kafka Connect (Source connector / Sink connector)
          - CDC connector -> Search index (e.g. Solr) / Database / Data warehouse / Cache
        - Kafka Streams (ksqlDB)
      - Control Plane
        - KRaft
          - Scale to millions of partitions, easier to maintain and set-up
          - Improve stability, easier to monitor, support and administer
          - Single security model
          - Faster controller shutdown and recovery time
        - ZooKeeper (leader + followers)
          - Manages brokers
          - Performs leader election for partitions
          - Sends notifications
      - Others
        - Cluster (the minimum number of nodes in ZooKeeper is 3 because of the quorum attribute)
          - Replication (multiple clusters): active-passive vs active-active
        - Backpressure
        - Monitoring (JMX metrics) and Operations
        - Security
      - Reasons to fast
        - Avoids Random Disk Access (sequential write)
        - Memory Mapped Files (mmap)
        - Zero Copy (receives bytes and sends bytes, [原理](https://www.jianshu.com/p/2581342317ce))
        - Batch Data in Chunks
        - Can Scale Horizontally

### Backend

- API architecture styles
  - [REST](http://www.ruanyifeng.com/blog/2014/05/restful_api.html): public APIs
    - URL = &lt;**scheme**>://&lt;user>:&lt;password>@&lt;**host**>:&lt;port>/&lt;**path**>;&lt;params>?&lt;query>#&lt;fragment>
    - Versioning
      - Version number in the URL
      - HTTP Accept header
    - Media Type & Content-Type
    - Identity Access Management (IAM)
      - Authentication (AuthN: who you are)
        - Basic authentication & Digest authentication
        - Login form, HTTP authentication
        - Key management (cryptographic keys)
      - Authorization (AuthZ: what you can do)
        - Role-based access control (RBAC)
        - URL access controls
        - Access control list (ACL)
          - Filesystem ACL
          - Network ACL
          - SQL ACL
      - References: [Intro to IAM](https://auth0.com/intro-to-iam/), [What is IAM](https://www.cloudflare.com/learning/access-management/what-is-identity-and-access-management/)
    - Design of REST APIs
      - Identify participants
      - Identify activities
      - Break into steps
      - Create API definition
        - Identify the resources
          - Items resource: list, view, search, add, edit
        - Map activities to resource lifecycle (map actions to HTTP Nouns & Verbs)
          - Mapping: GET /items, GET /items/:id, GET /items?search=param, POST /items/, PUT /items/:id
        - Map remaining activities to custom actions
          - Relationships types: Independent, Dependent, Associative
      - Validate API
      - References
        - [Sequence diagram](https://en.wikipedia.org/wiki/Sequence_diagram)
        - [Architectural constraints](https://restfulapi.net/rest-architectural-constraints/)
        - [How We Design Our APIs at Slack](https://slack.engineering/how-we-design-our-apis-at-slack/)
        - [Evolving API Pagination at Slack](https://slack.engineering/evolving-api-pagination-at-slack/)
        - [RESTful API resources](https://github.com/marmelab/awesome-rest)
  - RPC: communicates between processes, requests between services owned by the same organization / datacenter
    - Thrift & Avro
    - [gRPC](https://github.com/grpc-ecosystem/awesome-grpc): HTTP/2 & Protocol Buffers
    - Finagle: Futures
  - GraphQL: asking for specific fields on objects
  - WebSocket
  - Webhook
  - Simple Object Access Protocol (SOAP, [SOAP vs REST](https://aws.amazon.com/compare/the-difference-between-soap-rest/))

- Design patterns
  - Object oriented programming (OOP): Polymorphism
  - Creational Patterns: Factory, Singleton
  - Structural Patterns: Decorator, Adapter, Facade, Composite, Proxy
  - Behavioral Patterns: Observer, Command, Template, Iterator, State
  - Others: Lazy loading
  - J2EE Patterns: Compound (MVC)
  - Principles (SOLID)
    - Open Close Principle
    - Dependency Inversion
    - Liskov Substitution
    - Single Responsibility
    - Interface Segregation

- [Java](https://github.com/akullpp/awesome-java)
  - JVM ([stack frame](https://www.artima.com/insidejvm/ed2/jvm2.html))
    - Architecture: Class Loader - JVM Memory - Execution Engine
    - Application program - Tomcat container - **JVM** process - Operating system - Physical server
  - Spring
    - Core
      - Inversion of Control (IoC) Container
        - Bean life cycle: bean instantiated -> dependencies injected -> internal Spring processing -> custom init method -> destroy (except for the "prototype" scoped bean)
      - Annotation: Spring configuration (vs: XML)
        - Inversion of Control: Component
        - Dependency Injection: Autowired, Qualifier, Value, Bean, Configuration, PropertySource
        - Bean scope & life cycle: Scope, PostConstruct, PreDestroy
        - Spring MVC: Controller, RequestMapping, RequestParam, ModelAttribute
        - Hibernate (ORM): Entity, Table, Id, GenerateValue, OneToOne, ManyToOne, OneToMany, ManyToMany
        - Data Access Object (DAO) & Service: Repository, Service, Transactional
    - Spring Aspect oriented programming (AOP)
      - Web layer - Service layer - Repository layer
      - Use cases: logging, security, transaction, exception handling, API management
      - Support: Method-level join points & Run-time code weaving (vs: AspectJ)
      - Annotation: Aspect, Before, AfterReturning, AfterThrowing, After, Around, Pointcut
    - Spring Security (Servlet filter)
      - [Secure a Spring Boot REST API with JSON Web Token](https://medium.com/better-programming/secure-a-spring-boot-rest-api-with-json-web-token-reference-to-angular-integration-e57a25806c50)
    - Spring REST
      - Annotation: RestController, PathVariable, ExceptionHandler, ControllerAdvice, RequestBody
    - Spring Boot (initializr [link](https://start.spring.io/))
      - Solution: perform auto-configuration, provide an embedded HTTP server, resolve dependency conflicts
      - Actuator (endpoints [list](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints))
      - Property (properties [list](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html))
    - DAO techniques
      - Hibernate API
        - Fetch: lazy vs eager
      - Standard Java Persistence API (JPA)
      - Spring Data JPA (Spring Data REST)
    - Spring WebFlux
      - Reactor: Flux, Mono
      - Netty
    - Spring Cloud
    - Projects: [link](https://spring.io/projects)
  - RxJava (Reactive programming)
    - Obeservable and Observers (vs: Iterator)
      - Variants: Single, Maybe, Completable
    - Operators
      - types: Suppressing, transforming, reducing, collection, error recovery, action
    - Combining observables
    - Subjects - Replay / Cache
    - Concurrency and Parallelization
      - Schedulers (subscribeOn vs observeOn)
    - Flowable and Subcriber
      - Backpressure (vs: buffer / window, throttle, switch)
    - Reactive Streams

- [Go](https://github.com/avelino/awesome-go)
  - [pointer](https://www.runoob.com/go/go-pointers.html), [channel](https://www.runoob.com/w3cnote/go-channel-intro.html)

- [Python](https://github.com/vinta/awesome-python)
  - [cProfile](https://docs.python.org/3/library/profile.html), [timeit](https://docs.python.org/3/library/timeit.html)
  - Command line: [click](https://click.palletsprojects.com/)
  - [Dask](https://docs.dask.org/en/stable/dataframe.html) vs Koalas
  - Concurrent and parallel programming: Celery, Pyro5, RPyC, mpi4py, PyCUDA
  - [Status of Python Versions](https://devguide.python.org/versions/)
  - [PyPI packages](https://pypistats.org/top)

### Frontend

- Basic topics
  - WWW standards
    - CSS
    - DOM
    - SVG
    - XML
    - HTML
  - JavaScript
    - Vue.js
      - Vue Instance - Virtual DOM - DOM
      - VueResource, VueRouter, Vuex
        - MVVM: two-way data bindings ([双向绑定](https://www.liaoxuefeng.com/wiki/1022910821149312/1109527162256416))
      - Developer Tools: Vue.js devtools
    - Electron
  - Dart
  - Others
    - Swift
      - SwiftUI
    - WeChat Mini Program
    - [Fonts](https://www.cdnfonts.com)
    - [W3Techs - World Wide Web Technology Surveys](https://w3techs.com/)

### System design

- Distributed System Trade-offs
  - Performance vs Scalability
  - Throughput vs Latency
  - Availability vs Consistency

- Performance
  - **If the system goes slow**: scalability, performance
  - Common metrics
    - Throughput: number of tasks completed per unit time (Batch)
      - hps, tps, qps: number of HTTP requests/Transactions/Queries per second
    - Response time = transport latency + processing time (Stream)
      - Latency: time elapsed between start of the task and its finish
      - mean / average, p50 (median), p95, p99, p999
    - Number of concurrent sessions/users (Concurrency = throughput * latency)
    - Resource utilization: CPU (interrupts per second), Memory, Network (bandwidth, connection state), Disk I/O, etc.
  - Scalability
    - Hardware
    - Operating system (Linux: transparent huge page)
    - JVM
    - Infrastructure: web container, database connection pooling, MVC framework
      - Moniter the system and use automation tools
    - Architecture (clustered architecture)
      - Horizontal Scale: split tiers into individual services
        - Load balancing
        - Auto scaling policies
      - Stateless Architecture ([Stateful vs Stateless Architecture: Why Stateless Won](https://www.virtasant.com/blog/stateful-vs-stateless-architecture-why-stateless-won))
      - Data Sharding (shard key, hotspotting)
      - Data Replication: global/multiple data center
      - Cache (read-through vs cache-aside, write-through vs write-around vs write-back)
      - Host static assets in CDN
      - Async Processing & Message Broker
    - Programming: algorithms, data structure, design pattern, asynchronous I/O

- Availability
  - **If the system goes down**: reliability, resiliency (SPOF: single point of failure), availability
  - Common metrics
    - Uptime (Failover time)
    - Mean time between failures (MTBF)
    - Mean time to repair/recover (MTTR)
  - Reliability
    - Load balancing
      - Features: Routing and traffic management, Health checks
      - Algorithms: round robin, round robin with weighted server, least connections, least response time, source IP hash, URL hash
      - Hardware LB - Software LB: HAProxy
      - Global server load balancing (GSLB)
    - Read replicas
    - Fault and latency tolerance: message broker, Hystrix (Circuit Breaker pattern: cascading failures), Chaos Monkey
    - Monitoring & Profiler
    - Flow control & degrade
    - Disaster recovery
      - Metrics
        - Data loss: Recovery Point Objective (RPO)
        - Accecptable downtime: Recovery Time Objective (RTO)
      - References
        - [Disaster recovery options in the cloud](https://docs.aws.amazon.com/whitepapers/latest/disaster-recovery-workloads-on-aws/disaster-recovery-options-in-the-cloud.html)
        - [Databricks Disaster Recovery](https://learn.microsoft.com/en-us/azure/databricks/admin/disaster-recovery#inside-region-high-availability-guarantees)

- Maintainability: operability, simplicity, evolvability

- The Architecture Process
  - Understand the System’s Requirements
  - Understand the Non-Functional Requirements (NFR)
    - [Establishing effective service level objectives](https://www.datadoghq.com/blog/establishing-service-level-objectives/) (SLOs)
    - [How to create programmatic service level indicators](https://newrelic.com/blog/how-to-relic/programmatic-service-level-indicator) (SLIs)
    - [AWS service level agreements](https://aws.amazon.com/legal/service-level-agreements) (SLAs)
  - Map the Components (logic diagram, technical diagram, physical diagram)
  - Select the Technology Stack
    - [Zalando Tech Radar](https://opensource.zalando.com/tech-radar/)
  - Design the Architecture
  - Write Architecture Document
  - Support the Team

- Edge Computing
  - Network architectural pattern for compute and storage
    - Networking + Storage + Compute + Management
    - Edge computing leverages federated architectures
  - Components
    - Sensor/Data input
    - Edge device/Computer: processor, solid-state storage (SSD), network interfaces (5G, wifi, bluetooth, etc.), operating system, machine learning (e.g. Raspberry Pi)
    - Cloud-based Central Computer: databases (e.g. AWS IoT)
  - Considerations
    - Security: sensors, device, backend cloud based systems
    - Governance (integrated with all security): use of services, policies
    - Management (device side - cloud side): long-term operation, updates, hardware, network
    - Data management: storage, metadata, security, business continuity, disaster recovery, change management
    - Operations: monitor, consistent, automate, visibility/access/identity
    - AI and machine learning

- References
  - [服务端高并发分布式架构演进之路](https://segmentfault.com/a/1190000018626163)
  - [What is Hub and Spoke Topology](https://www.cbtnuggets.com/blog/technology/networking/what-is-hub-and-spoke-topology)

### Practice

- Cloud
  - [FinOps Framework](https://www.finops.org/framework/)
  - Comparison
    - [Compare AWS and Azure services to Google Cloud](https://cloud.google.com/free/docs/aws-azure-gcp-service-comparison)
    - [AWS to Azure services comparison](https://docs.microsoft.com/en-us/azure/architecture/aws-professional/services)

- WBS (Work breakdown structure)
  - RFQ (Request for quotation), RFC(Request for comments), SOW (Statement of work)
  - PoC (Proof of concept)
  - **User story** & Feature list
    - An end user going through a domain-level process to achieve some valuable outcome
    - Who, What, Why, Acceptance Criteria (AC)
  - Architecture design
  - Coding, testing, release
  - Maintenance & Iterative and incremental development

- Development Approach
  - TDD (Test driven): state desired outcome as a test
  - BDD (Behavior driven): base tests on natural language descriptions of business functionality
  - FDD (Feature driven)
  - DDD (Domain driven): force software engineer to understand the business context
    - Bounded Context: break up complext areas into smaller parts
    - Reactive model (publish subscribe model, vs: Declarative model)
      - Entities communication
      - Message broker
    - Domain events
      - [Event storming](https://en.wikipedia.org/wiki/Event_storming): design a system that models the structure and flow of activities

- Coding
  - System design -> Code development -> System testing -> System monitoring -> Product Rollout
  - Packages
    - Maven Helper (IntelliJ plugin): dependency analyzer
    - JFrog Artifactory
    - [Packaging Python Projects](https://packaging.python.org/tutorials/packaging-projects/)
  - Guidelines
    - Python: isort, autopep8, black
    - [Dockerfile linter](https://github.com/hadolint/hadolint)
  - Debugging: Exception breakpoint, Conditional breakpoint, Suspend policy (thread vs VM), Evaluate
  - Code Review
    - Programming style
    - Code review best practice
      - [what to look for](https://blog.jetbrains.com/upsource/tag/what-to-look-for/)
      - Human reviewers should be doing what cannot be automated (automate everything you can)
      - Understand the constraints
      - Knowledge sharing (focus on how to understand the code easily)
      - Gateway type code review: should have a list of specific checks (not right time for: design patterns, SOLID, reusability)
      - Reviews should be small
      - Reviewing respond in a timely fashion
      - Comments with Why, When and What
  - Testability: unit test - integration test - system test/functional test/regression test, code coverage
    - Test doubles (unit test): fake, dummy, stub, mock, spy

- Project Management
  - Quality, Cost, Delivery (QCD)
  - Systems Development Life Cycle (SDLC)
  - Documentation: [mkdocs](https://www.mkdocs.org/), [mkdocs-material](https://squidfunk.github.io/mkdocs-material/)
  - Agile
    - Conway's law
    - Agile Release Train (ART)
  - Scrum: Transparency, Inspection, Adaptation
    - Scrum master
  - Waterfall: System and software requirements -> Analysis -> Design -> Coding -> Testing -> Operations
  - Project Management Committee ([PMC](https://www.apache.org/foundation/how-it-works.html))
  - [RACI](https://en.wikipedia.org/wiki/Responsibility_assignment_matrix)
  - Tools: TeamRetro, [danswer](https://github.com/danswer-ai/danswer)

- Soft Skills
  - [6 Business Skills Every Engineer Needs](https://online.hbs.edu/blog/post/business-skills-for-engineers)
  - [The Guerrilla Guide to Interviewing](https://www.joelonsoftware.com/2006/10/25/the-guerrilla-guide-to-interviewing-version-30/)
  - [Hiring Managers: Duties, Skills and How To Become One](https://www.indeed.com/career-advice/finding-a-job/hiring-manager)
  - [Scaling Engineering Teams via RFCs: Writing Things Down](https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/)
  - Leadership
    - Vision: articulates a realistic, desirable, and positive future state, indirectly answering where you are going
    - 4 Cs: culture, connectivity, clarity and courage
    - Blueprint: future state, current state, barriers or challenges, enhancers & support, and goals & actions
  - Presentation
    - Good communicator: someone who looks and sounds like they mean what they're talking about
    - Imagining how you want to be perceived will help you focus
    - Delivering one thought at one time
    - Two-way communication
    - Diaphragmatic breathing: taking slow breaths through the nose, and focusing on belly expansion with inhalation
  - Write up report: background, methods, results, conclusion
  - Others
    - [15 Signs Your Boss Likes You](https://www.indeed.com/career-advice/career-development/signs-your-boss-likes-you)
    - [Getting things "done" in large tech companies](https://www.seangoedecke.com/getting-things-done/)
